library(MotifAnalysis)
library(Rcpp)
library(testthat)
motif_file <- "/p/keles/ENCODE-CHARGE/volume1/ENCODE-Motifs/encode_motifs_for_fimo.txt"

if(FALSE) {
  # construct the test data set
  if(!file.exists("/p/keles/ENCODE-CHARGE/volume2/SNP/motif_scores.Rda")) {
    system.time(motif_library <- LoadMotifLibrary(motif_file))
    system.time(snpInfo <- LoadSNPData("/p/keles/ENCODE-CHARGE/volume2/SNP/hg19_allinfo.bed"))
    motif_library$matrix <- motif_library$matrix
    motif_library$motif <- motif_library$motif
    system.time(motif_scores <- ComputeMotifScore(motif_library, snpInfo, ncores = 20))
    system.time(save(motif_library, snpInfo, motif_scores, file = "/p/keles/ENCODE-CHARGE/volume2/SNP/motif_scores.Rda"))
  } else {
    system.time(load("/p/keles/ENCODE-CHARGE/volume2/SNP/motif_scores.Rda"))
  }
  trans_mat <- matrix(rep(snpInfo$prior, each = 4), nrow = 4)
  test_pwm <- motif_library$matrix[[1]]
  scores <- cbind(motif_scores$log_lik_a1[, 1], motif_scores$log_lik_a2[, 1])
  save(trans_mat, test_pwm, scores, snpInfo, file = "~/MotifAnalysis_git/MotifAnalysis/data/test_is.Rda")
}

data(test_is)

test_score <- test_pwm
for(i in seq(nrow(test_score))) {
  for(j in seq(ncol(test_score))) {
    test_score[i, j] <- exp(mean(log((test_pwm[i, -j]) / test_pwm[i, j])))
  }
}

## these are functions for this test only
drawonesample <- function(theta) {
  delta <- snpInfo$prior * t(test_score) ^ theta
  prob_start <- rev(apply(delta, 2, sum))
  sample <- sample(1:4, 19, replace = TRUE, prob = snpInfo$prior)
  id <- sample(seq(10), 1, prob = prob_start)
  sample[10] <- sample(1:4, 1, prob = delta[, 11 - id])
  sample <- c(sample,
              id,
              test_score[11 - id, sample[10]]
              )
  return(sample)
}
jointprob <- function(x) prod(test_pwm[cbind(seq(10), x)])
maxjointprob <- function(x) {
  maxp <- -Inf
  p <- -Inf
  for(i in 1:10) {
    p <- jointprob(x[i:(i+9)])
    if(p > maxp)
      maxp <- p
  }
  for(i in 1:10) {
    p <- jointprob(5 - x[(i+9):i])
    if(p > maxp)
      maxp <- p
  }
  return(maxp)
}
get_freq <- function(sample) {
  emp_freq <- matrix(0, nrow = 19, ncol = 4)
  for(i in seq(19)) {
    for(j in seq(4)) {
      emp_freq[i, j] <- sum(sample[i, ] == j - 1)
    }
  }
  emp_freq <- emp_freq / apply(emp_freq, 1, sum)
  return(emp_freq)
}

test_that("Error: quantile function computing are not equivalent.", {
  for(p in c(1, 10, 50, 90, 99) / 100) {
    delta <- .Call("test_find_percentile_diff", scores, p, package = "MotifAnalysis")
    delta.r <- as.double(sort(apply(scores, 1, function(x) -abs(diff(x))))[as.integer(p * nrow(scores)) + 1])
    expect_equal(delta, delta.r)
  }
})

test_that("Error: the scores for samples are not equivalent.", {
  
  p <- 0.1
  delta <- .Call("test_find_percentile_diff", scores, p, package = "MotifAnalysis")
  theta <- .Call("test_find_theta_diff", test_score, snpInfo$prior, snpInfo$transition, delta, package = "MotifAnalysis")

  ## Use R code to generate a random sample
  for(i in seq(10)) {
    sample <- drawonesample(theta)
    sample_score <- .Call("test_compute_sample_score_diff", test_pwm, test_score, sample[seq(19)] - 1, sample[20] - 1, package = "MotifAnalysis")
    expect_equal(sample[21], exp(sample_score[1]))
  }
  
  ## Use C code to generate a random sample
  for(i in seq(10)) {
    delta <- matrix(0, nrow = 40, ncol = 10)
    for(i in seq(10)) {
      delta[4 * (i - 1) + seq(4), 10] <- snpInfo$prior * test_score[11 - i, ] ^ theta
    }
    for(i in 1:10) {
      delta[4 * (i- 1) + seq(4), seq(9)] <- sum(snpInfo$prior * delta[4 * (i - 1) + seq(4), 10])
    }
    sample <- .Call("test_importance_sample", delta, snpInfo$prior, trans_mat, test_pwm, theta, package = "MotifAnalysis")
    start_pos <- sample[20] + 1
    adj_score <- test_score[11 - start_pos, sample[10] + 1]
    sample_score <- .Call("test_compute_sample_score_diff", test_pwm, test_score, sample[seq(19)], sample[20], package = "MotifAnalysis")
    expect_equal(adj_score, exp(sample_score[1]))
  }
  
})

test_that("Error: compute the normalizing constant.", {
  
  ## parameters
  p <- 0.1
  delta <- .Call("test_find_percentile_diff", scores, p, package = "MotifAnalysis")
  theta <- .Call("test_find_theta_diff", test_score, snpInfo$prior, snpInfo$transition, delta, package = "MotifAnalysis")
  
  ##
  const <- .Call("test_func_delta_diff", test_score, snpInfo$prior, trans_mat, theta, package = "MotifAnalysis")
  const.r <- sum(snpInfo$prior * t(test_score) ^ theta) / 10
  expect_equal(const, const.r)
    
})

test_that("Error: sample distributions are not expected.", {
  
  library(doMC)
  ## parameters
  p <- 0.1
  delta <- .Call("test_find_percentile_diff", scores, p, package = "MotifAnalysis")
  theta <- .Call("test_find_theta_diff", test_score, snpInfo$prior, snpInfo$transition, delta, package = "MotifAnalysis")
  delta <- matrix(0, nrow = 40, ncol = 10)
  for(i in seq(10)) {
    delta[4 * (i - 1) + seq(4), 10] <- test_score[11 - i, ] ^ theta
  }
  for(i in 1:10) {
    delta[4 * (i- 1) + seq(4), seq(9)] <- sum(snpInfo$prior * delta[4 * (i - 1) + seq(4), 10])
  }

  target_freq <- matrix(snpInfo$prior, nrow = 4, ncol = 19)
  mat <- snpInfo$prior * t(test_score) ^ theta
  wei <- apply(mat, 2, sum)
  mat <- mat / rep(apply(mat, 2, sum), each = 4)
  mat <- mat * rep(wei, each = 4)
  target_freq[, 10] <- apply(mat, 1, mean)
  target_freq <- t(target_freq)
  target_freq <- target_freq / apply(target_freq, 1, sum)
  
  registerDoMC(4)
  
  results <- foreach(i = seq(20)) %dopar% {

    ## generate 1000 samples
    sample1 <- sapply(seq(1000), function(x)
                     .Call("test_importance_sample_diff",
                           delta, snpInfo$prior, trans_mat, test_score, theta, package = "MotifAnalysis"))
    emp_freq1 <- get_freq(sample1)
    
    sample2 <- sapply(rep(theta, 1000), drawonesample)
    emp_freq2 <- get_freq(sample2 - 1)
    
    max(abs(emp_freq1 - target_freq)) > max(abs(emp_freq2 - target_freq))
    
  }
  sum(unlist(results))

  print(pbinom(sum(unlist(results)), size = 20, prob = 0.5))
  
})

## Visual checks
if(FALSE) {
  
  plot(log(y <- sapply(seq(200) / 100 - 1, function(x)
            .Call("test_func_delta_diff", test_score, snpInfo$prior, snpInfo$transition, x, package = "MotifAnalysis"))))

## test the theta

  p_values_9 <- .Call("test_p_value_diff", test_pwm, test_score, snpInfo$prior, snpInfo$transition, scores, 0.1, package = "MotifAnalysis")
  p_values_8 <- .Call("test_p_value_diff", test_pwm, test_score, snpInfo$prior, snpInfo$transition, scores, 0.2, package = "MotifAnalysis")

  score_diff <- apply(scores, 1, function(x) abs(diff(x)))
  
  par(mfrow = c(1, 2))
  plot(log(p_values_9) ~ score_diff)
  plot(log(p_values_8) ~ score_diff)
  
  p_values_9 <- .Call("test_p_value_diff", test_pwm, test_score, snpInfo$prior, trans_mat, scores, 0.1, package = "MotifAnalysis")
  p_values_8 <- .Call("test_p_value_diff", test_pwm, test_score, snpInfo$prior, trans_mat, scores, 0.2, package = "MotifAnalysis")
  
  pval_test <- function(x) {
    delta <- .Call("test_find_percentile_diff", scores, x, package = "MotifAnalysis")
    theta <- .Call("test_find_theta_diff", test_score, snpInfo$prior, trans_mat, delta, package = "MotifAnalysis")
    const <- sum(snpInfo$prior * t(test_score) ^ theta) / 10
    print(const)
    sample <- sapply(rep(theta, 10000), drawonesample)
    pr <- apply(sample[1:19, ], 2, maxjointprob)
    sample1 <- sample2 <- sample3 <- sample
    sample1[10, ] <- sapply(sample1[10, ], function(x) seq(4)[-x][1])
    sample2[10, ] <- sapply(sample2[10, ], function(x) seq(4)[-x][2])
    sample3[10, ] <- sapply(sample3[10, ], function(x) seq(4)[-x][3])
    pr1 <- apply(sample1[1:19, ], 2, maxjointprob)
    pr2 <- apply(sample2[1:19, ], 2, maxjointprob)
    pr3 <- apply(sample3[1:19, ], 2, maxjointprob)

    log_diff <- log(c(pr1, pr2, pr3)) - log(pr)
    
    wei <- rep(const / sample[21, ] ^ theta, 3)
    message("target score: ", mean(log(sample[21, ])))
    message("mean diff score: ", mean(log_diff))
    message("mean weight: ", mean(wei))
    pval <- sapply(score_diff, function(x) sum(wei[log_diff > x]) / length(log_diff))
    return(pval)
  }

  pval_8 <- pval_test(0.2)
  pval_9 <- pval_test(0.1)
  
  rbind(quantile(pval_9, seq(10) / 200),
        quantile(p_values_9[, 1], seq(10) / 200),
        quantile(pval_99, seq(10) / 200),
        quantile(p_values_99[, 1], seq(10) / 200))
  
  plot(log(pval_8), log(p_values_8))
  abline(0,1)
  
  plot(log(pval_9), log(p_values_9))
  abline(0,1)

}
